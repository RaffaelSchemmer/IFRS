[Teórica/Prática] Segunda Aula: (Criando o Primeiro App Android)		
{
	[1] Criando o primeiro App
	
		- Defina um Nome
		- Utilize a linguagem Kotlin
	
	[2] O Gradle é quem compila todo o código Kotlin/Java e recursos que existirem (drawables, values .. etc).
	
		- Aguarde o icone verde App ficar sem o X
		- Isso significa que o Gradle está pronto para buildar o projeto
	
	[3] Esta é a estrutura de arquivos/diretórios do projeto:
	
		- Em project -> app -> src -> main 
		
			- java -> package
			
				- Vamos colocar os fontes kotlin (kt) em 3 pastas
				
					- model: Model cuida das regras 
					- controller: Controller da interação
					- view: View da interface
		
		- Em project -> app -> res
		
			- layout - Contém arquivos XML que definem as telas e componentes visuais do app
			- drawable - Armazena imagens/icones
			- mipmap - Usado para ícones do app
			- values - Contém arquivos XML que guardam valores reutilizáveis (estilos)
	
	[4] Inserindo o Layout ConstraintLayout
		
		- Em res clique em New -> XML -> Layout XML File
		
			Layout Name: layout_main
			Root Tag: androidx.constraintlayout.widget.ConstraintLayout
	
	[5] Caso o editor de layout não tenha carregado:
	
		- Navegue no project -> app -> res -> Layout -> layout_main e abra o XML
		- O editor de design irá aparecer carregando o layout em branco
	
		- No topo da tela existem 3 botões chamados code - split - design
		
			- Clicando em code você terá apenas o XML
			- Em split você terá o XML e o design
			- Em design você terá apenas o builder de interface
			- O professor sugere o split para editar o design e ver o XML sendo alterado
	
	[6] Em AndroidManifest.xml vamos adicionar a view principal/inicial do projeto:
		
	    <activity android:name=".MainActivity" android:exported="true">
			<intent-filter>
				<action android:name="android.intent.action.MAIN" />
				<category android:name="android.intent.category.LAUNCHER" />
			</intent-filter>
		</activity>

	[7] Antes de rodar nosso app removeremos uma actionbar:
		
		- Em app -> src -> values -> themes.xml
		
			- Troque o parent do style_name para NoActionBar
	
	[8] Crie em app -> src -> main -> java -> package a classe (view) MainActivity.kt
	
		package com.ifrsexample.primeiroapp

		import androidx.appcompat.app.AppCompatActivity
		import android.os.Bundle
				
		class MainActivity : AppCompatActivity() {
			
			override fun onCreate(savedInstanceState: Bundle?) 
			{
				super.onCreate(savedInstanceState)
				setContentView(R.layout.layout_main)
			}
		}

	[9] Um pouco sobre o ConstraintLayout
	
		- É um layout poderoso e flexível do Android que permite posicionar elementos relacionando-os entre si ou ao container pai usando restrições (constraints).
		- Facilita criar interfaces responsivas que se adaptam a diferentes tamanhos e orientações de tela
	
		- Propriedades do Layout:
		
			- Preenche toda tela do device (android)
				
				- android:layout_width= "match_parent"
				- android:layout_height= "match_parent"
				- android:background="@android:color/black"

				
	[10] Inserindo um botão no centro da tela com tamanho fixo

		<Button
			
			android:id="@+id/button1" 
			android:layout_width="151dp"
			android:layout_height="98dp"
			android:text="BOTAO"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintTop_toTopOf="parent" 
		/>
		
		[*]
	
			val buttonTop = findViewById<Button>(R.id.buttonTop)
			val buttonBottom = findViewById<Button>(R.id.buttonBottom)

			// -------- SET --------

			// 1. Texto
			buttonTop.text = "Novo texto Top"
			buttonBottom.text = "Novo texto Bottom"

			// 2. Tamanho do texto (em sp)
			buttonTop.textSize = 24f
			buttonBottom.textSize = 24f

			// 3. Cor do texto
			buttonTop.setTextColor(Color.parseColor("#FF0000"))
			buttonBottom.setTextColor(Color.parseColor("#00FF00"))

			// 4. Background (cor ou drawable)
			buttonTop.setBackgroundColor(Color.parseColor("#FFFF00"))
			buttonBottom.setBackgroundColor(Color.parseColor("#0000FF"))

			// 5. Visibilidade
			buttonTop.visibility = View.VISIBLE   // ou View.INVISIBLE / View.GONE
			buttonBottom.visibility = View.VISIBLE

			// 6. Alinhamento do texto interno (gravity)
			buttonTop.gravity = Gravity.CENTER
			buttonBottom.gravity = Gravity.CENTER

			// 1. Texto
			val textoTop = buttonTop.text.toString()
			val textoBottom = buttonBottom.text.toString()

			// 2. Tamanho do texto (em px → converter para sp se quiser)
			val tamanhoPxTop = buttonTop.textSize
			val tamanhoSpTop = tamanhoPxTop / resources.displayMetrics.scaledDensity

			val tamanhoPxBottom = buttonBottom.textSize
			val tamanhoSpBottom = tamanhoPxBottom / resources.displayMetrics.scaledDensity

			// 3. Cor do texto (ARGB)
			val corTextoTop = buttonTop.currentTextColor
			val corTextoBottom = buttonBottom.currentTextColor

			// 4. Background
			val backgroundTop = buttonTop.background
			val backgroundBottom = buttonBottom.background

			// 5. Visibilidade
			val visibilidadeTop = buttonTop.visibility  // View.VISIBLE / View.INVISIBLE / View.GONE
			val visibilidadeBottom = buttonBottom.visibility

			// 6. Gravity
			val gravidadeTop = buttonTop.gravity
			val gravidadeBottom = buttonBottom.gravity

	[11] Inserindo um botão no centro da tela com tamanho relativo a tela/pai
	
		<Button

        android:id="@+id/button4"
        android:text="Button"
        app:layout_constraintWidth_percent="0.4"
        app:layout_constraintHeight_percent="0.2"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        />


	[12] Inserindo dois botões na vertical centralizados com tamanho relativo a tela/pai	
	
		<Button
		
			android:id="@+id/buttonTop"
			android:layout_width="200dp"
			android:layout_height="wrap_content"
			android:text="Botão 1"
			android:textSize="24sp"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintTop_toTopOf="parent"
			app:layout_constraintBottom_toTopOf="@id/buttonBottom"
			app:layout_constraintVertical_chainStyle="packed" 
		/>

		<Button
			
			android:id="@+id/buttonBottom"
			android:layout_width="200dp"
			android:layout_height="wrap_content"
			android:text="Botão 2"
			android:textSize="24sp"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintTop_toBottomOf="@id/buttonTop"
			app:layout_constraintBottom_toBottomOf="parent" 
		/>
		
	[13] Inserindo dois botões na horizontal centralizados com tamanho relativo a tela/pai	
	
	    <Button
			android:id="@+id/buttonLeft"
			android:layout_height="wrap_content"
			android:text="Botão 1"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintEnd_toStartOf="@+id/buttonRight"
			app:layout_constraintTop_toTopOf="parent"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintWidth_percent="0.4"
			app:layout_constraintHorizontal_chainStyle="spread" 
		/>
	
		<Button
			android:id="@+id/buttonRight"
			android:layout_height="wrap_content"
			android:text="Botão 2"
			app:layout_constraintStart_toEndOf="@id/buttonLeft"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintTop_toTopOf="parent"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintWidth_percent="0.4" 
		/> 
	
	[14] Todo elemento visual possui um @id/botao:
	
		- Ele é como uma chave primária do botão
		- Cada botão terá um @id diferente
		- Utilizamos ele para acessar o componente na view (código kotlin)
	
	[15] Se você olhar no xml:
		
		- Algumas propriedades são associadas a app e outras a android
		- Tudo o que for android está associado ao SDK
		- Tudo o que for app está associado a bibliotecas externas
			
	[16] Estas são as propriedades mais importantes do botão

		- text : Define o texto (string) para o botão
		
		- textColor	: Alterando a cor do texto do botão ("@android:color/white")
	
		- textSize : Define o tamanho do texto (sempre em sp) do botão
			- sp respeita o tamanho da fonte do usuário/celular
			
		- backgroundTint : Alterando a cor do botão ("#FF0000")
		
		- visible : Define a visibilidade do botão (visible/invisible)
		
		- gravity :	Altera o posicionamento do texto dentro do botão (left/center/right)
	
	[*] Set e Get das propriedades
	
		// ---------- SET ----------

		// 1. Texto
		botao.text = "Clique aqui"

		// 2. Cor do texto (usando cor do sistema)
		botao.setTextColor(ContextCompat.getColor(this, android.R.color.white))
		// ou cor personalizada
		botao.setTextColor(Color.parseColor("#FFFFFF"))

		// 3. Tamanho do texto (em sp)
		botao.textSize = 18f  // sempre em "sp" automaticamente

		// 4. Cor de fundo (backgroundTint)
		botao.backgroundTintList = ColorStateList.valueOf(Color.parseColor("#FF0000"))

		// 5. Visibilidade
		botao.visibility = View.VISIBLE        // visível
		// botao.visibility = View.INVISIBLE   // invisível (reserva espaço)
		// botao.visibility = View.GONE        // invisível (remove espaço)

		// 6. Posicionamento do texto (gravity)
		botao.gravity = Gravity.CENTER   // Gravity.LEFT / Gravity.RIGHT / Gravity.CENTER


		// ---------- GET ----------

		// 1. Texto
		val texto = botao.text.toString()

		// 2. Cor do texto (retorna um int ARGB)
		val corTexto = botao.currentTextColor

		// 3. Tamanho do texto (em px → converter para sp se quiser)
		val tamanhoPx = botao.textSize
		val tamanhoSp = tamanhoPx / resources.displayMetrics.scaledDensity

		// 4. Cor de fundo (backgroundTint)
		val corFundo = botao.backgroundTintList?.defaultColor

		// 5. Visibilidade
		val visibilidade = botao.visibility  // retorna View.VISIBLE, View.INVISIBLE ou View.GONE

		// 6. Gravity
		val gravidade = botao.gravity
		
	[17] Estes são os eventos mais importantes do botão
	
		- onClick : Clique
			
			val curtoClick = findViewById<Button>(R.id.botao)
			curtoClick.setOnClickListener {
				Toast.makeText(getApplicationContext(), "CLICK", Toast.LENGTH_SHORT).show()
			}

		- onLongClick : Clique Longo
		
			val curtoClick = findViewById<Button>(R.id.botao)
			curtoClick.setOnLongClickListener {
				Toast.makeText(getApplicationContext(), "CLICK", Toast.LENGTH_SHORT).show()
				true
			}
				
	[*] Compilando o projeto
	
		Clique em Play
		Acompanhe pelo build a compilação (icone martelo)
		
	[*] Executando o projeto
	
		Clique em Runing Devices para abrir o AVD (emulador)
		Acompanhe a execução do App pelo Logcat (icone gato)
				
	[18] Inserindo um switch na tela
	
		<Switch
        android:id="@+id/switch4"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:scaleX="2.5"
        android:scaleY="2.5"
        android:text=""
		android:checked="false"
        android:textSize="56sp"
        android:thumbTint="@android:color/holo_blue_bright"
        android:trackTint="@android:color/white"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
		
	[16] Estas são as propriedades mais importantes do switch
	
		thumbTint : Define a cor do botão "@android:color/holo_blue_bright"
        trackTint : Define a cor da trilha "@android:color/white"
        scaleX : Define o tamanho em X "2.5"
        scaleY : Define o tamanho em Y "2.5"
        checked : Habilita ou não o switch "false"
	
	[*]
	
		val meuSwitch = findViewById<Switch>(R.id.switch4)

		// Estado ligado/desligado
		meuSwitch.isChecked = false

		// Escala
		meuSwitch.scaleX = 2.5f
		meuSwitch.scaleY = 2.5f

		// Texto e tamanho
		meuSwitch.text = ""
		meuSwitch.textSize = 56f  // em sp

		// Cor do botão (thumb) e trilha (track)
		meuSwitch.thumbTintList = ColorStateList.valueOf(
			ContextCompat.getColor(this, android.R.color.holo_blue_bright)
		)
		meuSwitch.trackTintList = ColorStateList.valueOf(
			ContextCompat.getColor(this, android.R.color.white)
		)

		// Visibilidade
		meuSwitch.visibility = View.VISIBLE  // ou View.INVISIBLE / View.GONE

		// Estado ligado/desligado
		val estaMarcado = meuSwitch.isChecked

		// Escala
		val escalaX = meuSwitch.scaleX
		val escalaY = meuSwitch.scaleY

		// Texto e tamanho
		val textoAtual = meuSwitch.text.toString()
		val tamanhoPx = meuSwitch.textSize
		val tamanhoSp = tamanhoPx / resources.displayMetrics.scaledDensity

		// Cor do botão (thumb) e trilha (track)
		val corThumb = meuSwitch.thumbTintList?.defaultColor
		val corTrack = meuSwitch.trackTintList?.defaultColor

		// Visibilidade
		val visibilidade = meuSwitch.visibility  // View.VISIBLE / View.INVISIBLE / View.GONE

	[17] Estes são os eventos mais importantes do botão
 
		val mySwitch = findViewById<Switch?>(R.id.switch4)
        mySwitch.setOnClickListener(object : View.OnClickListener {
            override fun onClick(v: View?) {
                if (mySwitch.isChecked()) {
                    // O Switch está ligado
                    Toast.makeText(getApplicationContext(), "Ligado", Toast.LENGTH_SHORT).show()
                } else {
                    // O Switch está desligado
                    Toast.makeText(getApplicationContext(), "Desligado", Toast.LENGTH_SHORT).show()
                }
            }
        })
		
	[18] Adicionando uma imagem ao layout
	
		<ImageView
        android:id="@+id/imageView1"
        android:layout_width="150dp"
        android:layout_height="150dp"
        android:src="@mipmap/ic_launcher"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:alpha="0.9"
        android:rotation="90"
        android:contentDescription="Imagem"
		app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"/>

	[*]
	
		val imageView = findViewById<ImageView>(R.id.imageView1)

		// ---------- SET ----------

		// 1. Imagem (src)
		imageView.setImageResource(R.mipmap.ic_launcher)  
		// ou de drawable: imageView.setImageResource(R.drawable.minha_imagem)

		// 2. ScaleType
		imageView.scaleType = ImageView.ScaleType.FIT_CENTER
		// outros valores: CENTER_CROP, CENTER_INSIDE, FIT_XY...

		// 3. Ajustar limites (adjustViewBounds)
		imageView.adjustViewBounds = true

		// 4. Transparência (alpha) - valor de 0.0 a 1.0
		imageView.alpha = 0.9f

		// 5. Rotação (em graus)
		imageView.rotation = 90f

		// 6. Descrição de conteúdo (contentDescription)
		imageView.contentDescription = "Imagem"


		// ---------- GET ----------

		// 1. Imagem atual → pega o Drawable
		val imagemDrawable = imageView.drawable

		// 2. ScaleType
		val tipoScale = imageView.scaleType

		// 3. Ajuste de limites
		val ajustaLimites = imageView.adjustViewBounds

		// 4. Transparência
		val transparencia = imageView.alpha

		// 5. Rotação
		val rotacaoAtual = imageView.rotation

		// 6. Descrição de conteúdo
		val descricao = imageView.contentDescription?.toString()

	[19] Adicionando um botão com imagem 
	
		<ImageButton
			android:id="@+id/imageButton1"
			android:layout_width="wrap_content"
			android:layout_height="wrap_content"
			android:background="?attr/selectableItemBackgroundBorderless"
			android:contentDescription="Botão de imagem"
			android:src="@mipmap/ic_launcher"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintTop_toTopOf="parent"
		/>

	[*]
		val imageButton = findViewById<ImageButton>(R.id.imageButton1)

		// ---------- SET ----------

		// 1. Imagem exibida (src)
		imageButton.setImageResource(R.mipmap.ic_launcher)  
		// ou de drawable: imageButton.setImageResource(R.drawable.minha_imagem)

		// 2. Background (pode ser cor ou drawable)
		imageButton.setBackgroundResource(android.R.color.transparent)
		// ou cor customizada:
		imageButton.setBackgroundColor(Color.parseColor("#FF0000"))

		// 3. Descrição de conteúdo
		imageButton.contentDescription = "Botão de imagem"

		// 4. Alterar tamanho (programaticamente)
		imageButton.layoutParams.width = 200
		imageButton.layoutParams.height = 200
		imageButton.requestLayout()

		// 5. Transparência
		imageButton.alpha = 0.8f

		// 6. Rotação
		imageButton.rotation = 45f

		// 7. Escala da imagem dentro do botão
		imageButton.scaleType = ImageView.ScaleType.CENTER_CROP

		// ---------- GET ----------

		// 1. Imagem atual (Drawable)
		val imagemDrawable = imageButton.drawable

		// 2. Background atual
		val backgroundAtual = imageButton.background

		// 3. Descrição de conteúdo
		val descricao = imageButton.contentDescription?.toString()

		// 4. Largura e altura atuais
		val largura = imageButton.layoutParams.width
		val altura = imageButton.layoutParams.height

		// 5. Transparência
		val transparencia = imageButton.alpha

		// 6. Rotação
		val rotacaoAtual = imageButton.rotation

		// 7. ScaleType
		val tipoScale = imageButton.scaleType

	[20] Adicionando um texto
		
		<TextView
			android:id="@+id/textViewContador"
			android:layout_width="wrap_content"
			android:layout_height="wrap_content"
			android:text="0"
			android:textColor="#81EB05"
			android:textSize="150sp"
			app:layout_constraintBottom_toBottomOf="parent"
			app:layout_constraintEnd_toEndOf="parent"
			app:layout_constraintStart_toStartOf="parent"
			app:layout_constraintTop_toTopOf="parent" 
		/>
	
	[*]
	
		val textView = findViewById<TextView>(R.id.textViewContador)

		// ---------- SET ----------

		// 1. Texto
		textView.text = "10"

		// 2. Cor do texto
		textView.setTextColor(Color.parseColor("#81EB05"))
		// ou usando cor do sistema:
		// textView.setTextColor(ContextCompat.getColor(this, android.R.color.white))

		// 3. Tamanho do texto (em sp)
		textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 150f)

		// 4. Visibilidade
		textView.visibility = View.VISIBLE  // View.INVISIBLE ou View.GONE também são válidos

		// 5. Alinhamento do texto dentro do TextView (gravity)
		textView.gravity = Gravity.CENTER  // Gravity.LEFT / RIGHT / CENTER

		// ---------- GET ----------

		// 1. Texto
		val textoAtual = textView.text.toString()

		// 2. Cor do texto (retorna um int ARGB)
		val corTexto = textView.currentTextColor

		// 3. Tamanho do texto (em px → converter para sp)
		val tamanhoPx = textView.textSize
		val tamanhoSp = tamanhoPx / resources.displayMetrics.scaledDensity

		// 4. Visibilidade
		val visibilidade = textView.visibility  // retorna View.VISIBLE / View.INVISIBLE / View.GONE

		// 5. Alinhamento (gravity)
		val gravidade = textView.gravity

	[21] Estes são os eventos mais importantes do botão com imagem
	
		- onClick : Clique
			
			val curtoClick = findViewById<Button>(R.id.botao)
			curtoClick.setOnClickListener {
				Toast.makeText(getApplicationContext(), "CLICK", Toast.LENGTH_SHORT).show()
			}

		- onLongClick : Clique Longo
		
			val curtoClick = findViewById<Button>(R.id.botao)
			curtoClick.setOnLongClickListener {
				Toast.makeText(getApplicationContext(), "CLICK", Toast.LENGTH_SHORT).show()
				true
			}


	Atividades
	
	[1] Layout claro/escuro
	
		1.1. Switch → Troca da cor do layout
		1.2. Image → Insira uma imagem centralizada/transparente no layout
		1.3. Button → Botão “Diminuir/Acender” o nível de claro/escuro da tela
	
	[2] Controle de iluminação

		1.1. Switch → liga/desliga a lâmpada
		1.2. ImageButton → muda a imagem da lâmpada acesa ou apagada
		1.3. Button → botão “Diminuir/Acender” para reduzir ou aumentar brilho
	
	[3] Game rotação de imagem
	
		1.1. Image → Gera o logo do ifrs rotacionado
		1.2. ImageButton → Botões esquerda/direita permitem rotacionar a imagem
		1.3. Toast → Gere um toast quando imagem estiver reta
		1.4. Código que toca música quando acertou
		
		val soundPool = SoundPool.Builder().setMaxStreams(1).build()
        val soundId = soundPool.load(this, R.raw.audio, 1) // coloque o audio em res/raw

        fun tocarSom() {
            soundPool.play(soundId, 1f, 1f, 1, 0, 1f)
        }
		
	[4] Contador interativo

		1.1. ImageButton → incrementa valor
		1.2. ImageButton → decrementa valor
		1.3. Textview → Mostra o valor do contador
		1.4. Switch → ativa/desativa contagem automática a cada segundo de onde parou
		1.5. Toast → Gere um toast parabenizando quando o contador for divisível por 10
		1.6. Implementação do timer
		
			val runnable = object : Runnable {
				override fun run() {
					seconds++
					handler.postDelayed(this, 1000) // repete a cada 1 segundo
				}
			}
		
			// Para iniciar o timer
			handler.post(runnable)
			// Para parar o timer
			handler.removeCallbacks(runnable)

}